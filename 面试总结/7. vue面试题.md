## vue面试考察方面

- 框架的使用（基本使用，高级特性，周边插件）
- 框架的原理（基本原理的了解，热门技术的深度，全面性）
- 框架的实际应用，即设计能力（组件结构，数据结构）



## 基本使用

在这里，是一些日常使用的内容，在此列出来，可以思考平时是如何使用的，不太清楚的可以去看官方文档，跟着做一些demo。

- 插值、表达式、指令、动态属性、v-html
- computed 和 watch
- class 和 style、动态属性
- v-if 和 v-show
- 列表循环渲染v-for
  - key的重要性（后面涉及原理时再说）
  - v-for和v-if不能一起使用：会进行重复判断
- 事件
  - event参数，event是原生的
  - 事件修饰符
  - 观察事件被绑定到哪？绑定到了当前的元素
- 表单
  - v-model
  - 常见表单项：textarea、checkbox、radio、select
  - 修饰符：lazy、number、trim



### 1. 计算属性 vs 方法

**区别：** 我们可以将同一个函数定义成一个方法而不是计算属性。两者最终的结果是完全相同的。但是**计算属性是基于他们的响应式依赖进行缓存**。意味着依赖的值没有发生改变的话，多次访问计算属性的函数只会立即返回之前缓存的结果，不会再次执行函数。

**优点：** 进行了缓存以后，如果有一个性能开销较大的计算属性，它需要遍历一个巨大的数组并做大量的计算。我们如果进行了缓存，在依赖的数据没有变化时就可以直接返回结果，避免了性能的浪费。



### 2. 计算属性 vs 侦听属性

虽然计算属性在大多数的情况下更适合，但是也有需要侦听属性的时候。**当需要在数据变化时执行异步或开销较大的操作时**，这个方式是最有用的。

**使用区别：**

- `computed`可以设置`get`、`set`
- `watcher`可以设置`immediate`、`deep`
  - 正常情况下，`侦听属性`提供的函数是不会立即执行的，只有在对应的`vue data`发生变化时，`侦听属性`对应的函数才会执行。那如果我们需要`侦听属性`对应的函数立即执行一次，就可以给`侦听属性`提供一个`immediate`选项，并设置其值为`true`。
  - 如果我们对一个`对象类型`的`vue data`进行侦听，当这个对象内的属性发生变化时，默认是不会触发侦听函数的。设置`deep`为true，则可以对其进行一个深层次的监听。

**运用场景：**

- 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
- 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。



### 3. 动态属性

- class对象语法

  ```html
  <div
    class="static"
    v-bind:class="{ active: isActive, 'text-danger': hasError }"
  ></div>
  
  <div v-bind:class="classObject"></div>
  ```

  ```javascript
  export default {
  	data() {
    	return {
  			isActive: true,
    		hasError: false,
        classObject: {
          active: true,
          'text-danger': false
        },
  		}
    }
  }
  ```

- class数组语法

  ```html
  <div v-bind:class="[activeClass, errorClass]"></div>
  ```

  ```javascript
  export default {
  	data() {
    	return {
  			activeClass: 'active',
    		errorClass: 'text-danger'
  		}
    }
  }
  ```

- style对象语法

  ```html
  <div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
  <div v-bind:style="styleObject"></div>
  ```

  ```javascript
  export default {
  	data() {
    	return {
  			color: 'red',
      	fontSize: '13px',
        styleObject: {
          color: 'red',
          fontSize: '13px'
        }
  		}
    }
  }
  ```

- style数组语法

  ```html
  <div v-bind:style="[style1,style2]"></div>
  ```

  ```javascript
  export default {
  	data() {
    	return {
  			style1:{fontSize:'100px'},
  			style2:{background:'red'},
  		}
    }
  }
  ```



### 4. v-if 和 v-show 的区别

- **v-if** 是**真正**的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

- **v-show** 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。

所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。



### 5. 事件修饰符有哪些

为了解决这个问题，Vue.js 为 `v-on` 提供了**事件修饰符**。之前提过，修饰符是由点开头的指令后缀来表示的。

- `.stop`
- `.prevent`
- `.capture`
- `.self`
- `.once`
- `.passive`

```html
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>

<!-- 点击事件将只会触发一次 -->
<a v-on:click.once="doThis"></a>

<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
<!-- 而不会等待 `onScroll` 完成  -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<div v-on:scroll.passive="onScroll">...</div>
```



### 6. v-model

你可以用 `v-model` 指令在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 `v-model` 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。

`v-model` 会忽略所有表单元素的 `value`、`checked`、`selected` attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 `data` 选项中声明初始值。

`v-model` 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：

- text 和 textarea 元素使用 `value` property 和 `input` 事件；
- checkbox 和 radio 使用 `checked` property 和 `change` 事件；
- select 字段将 `value` 作为 prop 并将 `change` 作为事件。

```html
<input v-model='something'>
<!-- 相当于 -->
<input v-bind:value="something" v-on:input="something = $event.target.value">
```



## 组件的使用

- data为什么是一个函数？

- 如何理解单项数据流？

- 组件之间的通信？

- slot插槽

- 动态组件 & 异步组件

  

## 生命周期

### 1. 什么是生命周期？

Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。



### 2. 各个生命周期的作用

| 生命周期      | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| beforeCreate  | 组件实例被创建之初，组件的属性生效之前                       |
| created       | 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用 |
| beforeMount   | 在挂载开始之前被调用：相关的 render 函数首次被调用           |
| mounted       | el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子    |
| beforeUpdate  | 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前              |
| update        | 组件数据更新之后                                             |
| activited     | keep-alive 专属，组件被激活时调用                            |
| deactivated   | keep-alive 专属，组件被销毁时调用                            |
| beforeDestory | 组件销毁前调用                                               |
| destoryed     | 组件销毁后调用                                               |

生命周期示意图：

![1.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca74f183827f46~tplv-t2oaga2asx-watermark.awebp)



### 3. 在哪个生命周期内调用异步请求？

可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

- 能更快获取到服务端数据，减少页面 loading 时间；
- ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；



### 4. 在什么阶段可以访问DOM？

根据生命周期示意图，可以在mounted中访问操作DOM



### 5. Vue 的父组件和子组件生命周期钩子函数执行顺序？

- 加载渲染过程

父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

- 子组件更新过程

父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

- 销毁过程

父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed



### 6. $nextTick

> 原理：[Vue $nextTick 原理](https://www.cnblogs.com/gaosirs/p/10595326.html)

- Vue是异步渲染，data改变后DOM不会立即变化
- $nextTick会在DOM渲染后被触发，以获取最新的DOM



### 7. keep-alive

> 官方文档：[keep-alive](https://cn.vuejs.org/v2/api/#keep-alive)

当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。

相应的，也有两种专属的生命周期：（1）activited，组件激活（2）deactivated，组件销毁



## vue的高级特性

### 1. mixin

> 官方文档：[混入](https://cn.vuejs.org/v2/guide/mixins.html#%E5%9F%BA%E7%A1%80)

对于一些公用的逻辑，可以采用混入的方式进行。比如在做表单校验逻辑时，很多用到表单的地方都需要使用，我们可以单独的定义一个form.js作为表单的混入。



## Vue插件

- Vuex
- Vue-Router



### 1. Vuex

- 基本的概念和使用
- 一些场景设计



**（1）基本概念**

- state、mapState
- getters、mapGetters
- action、mapActions（可以做异步操作）
- mutation、mapMutations（同步操作）
- dispatch
- commit



###  2. Vue-Router

- 路由模式：hash、H5 history
- 路由配置：动态路由、懒加载



## Vue原理

- 数据双向绑定
- 虚拟DOM
- 模板编译
