## 写在前面

前面几个月一直在准备基础知识，深入的了解了js、浏览器、计算机网络、vue、webpack等等。让我陷入了一个误区，那就是将面试当作了高考，要把所有的知识点全部复习到位。事实上并不是这样，前端的知识体系大而复杂，各个方向细开展可能这几个月是学习不完的。

但是这并不是说之前的准备毫无作用，至少某些方面上来说。过去一年的学习，我从一点不懂，到接触前端，到使用框架，然后搭建自己的博客，参与项目和比赛，在人人实习，在腾讯实习。期间学习过新的知识点，也一直试图将所有的基础知识全部总结，很遗憾，我做不到。我承认自己没有那么强的能力，或者说那么多的时间去系统的学习所有的前端知识体系，但是我对前端的热爱一定会让我坚持下去，相信后面我会一点点的去学习总结

在这个特殊的八月份我经历了很多，总之，我现在需要全新全意的去准备秋招。而从现在开始，我也不会再去采取原来的方式试图去总结所有可能遇到的问题。想起gp对我说的一句话，当所有的面经你看到后80%心里都有数后，那时机已经差不多了。相比于三月份被快排、链表、cookie、闭包一类问题难到的我，几个月的学习间我已经有了自己的知识体系，所以现在开始刷面试题，有的放矢。

## html

## css

##### 1. 两栏布局

**html:**

```
<div class="box">
    <div class="left">左边</div>
    <div class="right">右边</div>
</div>
```

**css:**

```
// 1. 左浮动 + 右margin
.left {
    float: left;
    width: 200px;
    background: red;
    height: 400px;
}
.right {
    background-color: black;
    height: 200px;
    margin-left: 200px;
}
​
// 2. flex布局
.box {
    display: flex;
}
.left {
    flex: 0 0 auto
}
.right {
    flex: 1 1 auto
}
​
// 3. 相对定位
```

##### 2. 垂直水平居中

-   相对定位
-   flex布局
-   margin： 0 auto + line-height

##### 3. 什么是BFC

> [面试官：请说说什么是BFC？大白话讲清楚](https://juejin.cn/post/6950082193632788493)

"块级格式化上下文"， `BFC`是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用`BFC`呢，`BFC`可以看做是一个`CSS`元素属性。

**触发条件：**

-   overflow: hidden
-   display: inline-block
-   display: table-cell
-   display: flex
-   position: absolute
-   position: fixed

**解决问题：**

-   float的高度塌陷
-   margin边距重叠
-   两栏布局的问题

## js

##### 1. 写一个原型链继承

```javaScript
// 手写原型链
function child() {
  this.name = "child"
}

function father() {
  this.name = "father"
}

father.prototype.sayName = function() {
  console.log(this.name)
}

child.prototype = Object.create(father.prototype)
```

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bb6d38ccacd4f1a8e97632001eaebf0~tplv-k3u1fbpfcp-watermark.image)

##### 如何实现登录功能，密码加密如何加密

## 浏览器



## 计算机网络

##### 1. Get 和 post 的区别
> [你敢在post和get上刁难我，就别怪我装逼了](https://juejin.cn/post/6844903508370538503)
-   get用来获取数据，post用来提交数据
-   get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），而post无限制。
-   get请求的数据会附加在url之 ，以 " ？ "分割url和传输数据，多个参数用 "&"连接，而post请求会把请求的数据放在http请求体中。
-   get是明文传输，post是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的。
-   get请求会被浏览器主动cache，而post不会，除非手动设置。


##### 2. https加密过程

> [前端秋招保驾护————航浏览器篇](http://blog.wutortoise.cn/2021/08/10/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87)

##### 3. 什么是CDN

> [## CDN与DNS知识汇总](http://hpoenixf.com/DNS%E4%B8%8ECDN%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB.html)

CDN的全称是Content Delivery Network，即内容分发网络。通俗点就是用户访问的资源原本是存放在你自己的服务器，通过修改DNS让用户根据IP等情况来选择合适的CDN缓存服务器来获取资源。过程如下：

1.  当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。
1.  CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。
1.  用户向CDN的全局负载均衡设备发起内容URL访问请求。
1.  CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。
1.  区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。
1.  全局负载均衡设备把服务器的IP地址返回给用户
1.  用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

##### 4. TCP三次握手、四次挥手

##### 5. DNS解析的具体流程，用到什么协议，答案是UDP，解释为什么使用的是UDP协议

##### 6. http1.0 http1.1 http2.0的区别

##### 7. 如果想减少TCP连接次数，可以怎么操作，我的答案是采用http2.0，进行多路复用

## 操作系统

##### 1. 进程和线程的区别

##### 2. 进程之间的通信方式

## 数据库

##### 1. 事务的四大特性

##### 2. 数据库的数据类型有哪些

## 设计模式

**1. 观察者模式和发布订阅模式**

> [秋招保驾护航——vue篇之数据双向绑定](https://juejin.cn/post/6993373656051089421)


## 数据结构和算法

**1. 树的层序、前序、中序和后序遍历**

```javaScript
function TreeNode(val, left, right) {
  this.val = (val===undefined ? 0 : val)
  this.left = (left===undefined ? null : left)
  this.right = (right===undefined ? null : right)
}

// 递归的前序遍历
function preorderTraversal_recursion(root) {
  const result = []
  function preOrderTraverseNode(root) {
     // 遍历根节点
     if(root) result.push(root.val)
     // 遍历左子树
     if(root.left) preOrderTraverseNode(root.left)
     // 遍历右子树
     if(root.right) preOrderTraverseNode(root.right)
  }
  preOrderTraverseNode(root)
  return result
}

// 迭代的前序遍历
function preorderTraversal_iteration(root) {
  const result = []
  // 递归本质上就是使用栈来实现的，依次迭代就是显示的调用栈
  const stack = []
  // 判断是否为空节点
  if (root) {
    stack.push(root)
  } else {
    return result
  }
  // 遍历树
  while (stack.length > 0) {
    // 弹出栈顶，相当于遍历根节点
    var top = stack.pop()
    result.push(top.val)
    // 因为栈是先进后出，所以先push右节点
    if(top.right) stack.push(top.right)
    // push左节点
    if(top.left) stack.push(top.left)
  }
  return result
}

// 递归的中序遍历 
function inorderTraversal_recursion(root) {
  const result = []
  function inorder(root) {
    if(root.left) inorder(root.left)
    result.push(root.val)
    if(root.right) inorder(root.right)
  }
  if(root) inorder(root)
  return result
}

// 迭代的中序遍历
function inorderTraversal_interation(root) {
  const result = []
  const stack = []
  while (root || stack.length) {
    while (root) {
      stack.push(root)
      root = root.left
    }
    var top = stack.pop()
    result.push(top.val)
    root = top.right
  }
  return result
}

// 递归的后序遍历
function postorderTraversal_recursion(root) {
  const result = []
  function postorder(root) {
    if(root.left) postorder(root.left)
    if(root.right) postorder(root.right)
    result.push(root.val)
  }
  if(root) postorder(root)
  return result
}

// 迭代的后序遍历
function postorderTraversal_interation(root) {
  const result = []
  const stack = []
  var pre = null
  while (root || stack.length) {
    while (root) {
      stack.push(root)
      root = root.left
    }
    var top = stack.pop()
    // 注意此处需要判断右子树是否被遍历过，从而决定是否去遍历根节点
    if (!top.right || top.right === pre) {
      result.push(top.val)
      pre = top
      root = null
    } else {
      stack.push(top)
      root = top.right
    }
  }
  return result
}

// 该层序遍历输出的是一维数组
function levelOrder(root) {
  const result = []
  const stack = []
  if(root) stack.push(root)
  while (stack.length) {
    var top = stack.pop()
    result.push(top.val)
    if(top.right) stack.push(top.right)
    if(top.left) stack.push(top.left)
  }
  return result 
}

// 该层序遍历输出的是二维数组
function levelOrder_s(root) {
  const result = []
  const stack = []
  if(root) stack.push(root)
  while (stack.length) {
    result.push([])
    var len = stack.length
    for (let i=0; i<len; i++) {
      var top = stack.shift()
      result[result.length-1].push(top.val)
      if(top.left) stack.push(top.left)
      if(top.right) stack.push(top.right)
    }
  }
  return result 
}

// 根据前序遍历和中序遍历寻找二叉树
var buildTree = function(preorder, inorder) {
  function findTree(prf, pre, inf, ine) {
      console.log(prf+" "+pre+" "+inf+" "+ine)
      if (prf > pre || inf > ine) {
        return null
      }
      var root = new TreeNode(preorder[prf])
      var pos = inorder.indexOf(preorder[prf])
      var len = pos - inf
      if(prf === pre || inf === ine) {
        return root
      } else {
        root.left = findTree(prf+1, prf+len, inf, pos-1)
        root.right = findTree(prf+1+len, pre, pos+1, ine)
        return root
      } 
  }
  if (preorder.length) {
     var root = findTree(0, preorder.length-1, 0, inorder.length-1) 
  } else {
      var root = null
  }
  return root
}

var root = new TreeNode(3)
root.left = new TreeNode(9)
root.right = new TreeNode(20)
root.right.left = new TreeNode(15)
root.right.right = new TreeNode(7)

var preorder = [3,9,20,15,7]
var inorder = [9,3,15,20,7]
console.log(buildTree(preorder, inorder))
```

##### 2. DFS遍历DOM树的元素结点

##### 3. 大数相加

##### 4. 查找二叉树最近子节点









