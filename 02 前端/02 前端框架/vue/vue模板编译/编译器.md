## 编译器核心技术概览

Vue 的模版和 JSX 都属于特定领域的特定语言，它们的实现难度属于中低级别，只要掌握几本的编译技术理论即可以实现这些功能。



## 1 虚拟DOM

Vue为我们提供了**模版语法**，我们可以通过编写如下的代码获取我们想要的 dom 结构

```html
<template>
	<h1 @click="handler"></h1>
</template>
```

这并不是真实的 HTML 语句，因为模板语法里面我们可以使用 `v-if`、`v-for`、`v-on	`等指令，模板里的语法最终会被转换成虚拟 DOM 描述的 UI。如果你比较熟悉虚拟 DOM，你可以不使用模板，直接写**渲染（render）函数**。

```js
import {h} from 'vue'

export default {
  render() {
    return h('h1', { onClick: handler })
  }
}
```

这里的 **h 函数**是为了帮助我们编写虚拟 DOM 更加的轻松，其最终返回的内容如下：

```js
export default {
  render() {
    return {
      tag: 'h1',
      props: { onClick: handler }
    }
  }
}
```

一个组件要渲染的内容是通过**渲染函数**来描述的，也就是上述代码的 **render 函数**。Vue 会根据组件的 render 函数返回值拿到虚拟 DOM ，然后再经过**渲染器**的渲染，就可以把**虚拟 DOM** 渲染成**真实的 DOM**。



## 2 模板编译

上面我们讲了模板语法最终会被转换成渲染函数，渲染函数最终会返回成虚拟 DOM，以便后面的流程正常的进行。而模板语法转换成渲染函数便是**编译器**做的工作，对于如下的模板：

```html
<div @click="handler">
  click me
</div>
```

经过编译器的工作最终会转换成如下的渲染函数：

```js
render() {
  return h('div', { onClick: handler }, 'click me')
}
```



以我们熟悉的 .vue 文件为例，一个 .vue 文件就是一个组件

```vue
<template>
  <div @click="handler">
    click me
  </div>	
</template>

<script>
export default {
  data() {
    return {
      // 数据...
    }
  }，
  methods: {
		handler: function() {
      // 函数体...
    }
	}
}
</script>
```

`<template>` 标签里的内容就是模板内容，编译器会把模板内容编译成渲染函数并添加到 `<script>` 标签块的组件对象上，最终代码如下：

```js
export default {
  data() {
    return {
      // 数据...
    }
  }，
  methods: {
		handler: function() {
      // 函数体...
    }
	},
  render() {
    return h('div', { onClick: handler }, 'click me')
  }
}
```



## 3  传统编译器

编译器其实只是一段程序，它用于将 A 语言翻译成 B 语言。

- A 语言：源代码
- B 语言： 目标代码
- 源代码 -> 目标代码：编译

完整的编译一半包含以下几个步骤

- 词法分析
- 语法分析
- 语义分析
- 中间代码生成
- 优化
- 目标代码生成



## 4 Vue编译器

Vue 的模板作为 DSL（涉及一种领域特定的语言），其编译流程会有所不同。对 Vue 来说，源代码就是组件模板，目标代码就是能在浏览器上运行的 js 代码，或者其他拥有 js 运行时的平台代码

```html
<-- 源代码 !-->
<div>
  <h1 :id="dynamicId">
    Vue Template
  </h1>
</div>
```

```javascript
// 目标代码
function render() {
	return h('div', [
		h('h1', {id: dynamic}, 'Vue Template')
	])
}
```

Vue 的模板编译器首先对模板进行**词法分**析和**语法分析**，得到**模板 AST**。接着，将**模板 AST** 转换成 **JavaScriptAST**。最后，根据 **JavaScriptAST** 生成 **JavaScript 代码**（即渲染函数代码），具体流程如下：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44e9c0f5e84244ed848ba1a79fea17ae~tplv-k3u1fbpfcp-watermark.image?)



总的来说Vue编译的核心**主要是三个阶段**：parse、transform、generate。Vue 核心 compiler 的代码只是简单的调用了这三个函数：

```javascript
function compiler(template) {
  const ast = parse(template)
  transform(ast)
  const code = generate(ast.jsNode)
  
  return code
}
```



**第一步 parse：** 这里将**模板**转换成**模板AST**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0415701b0ea848318924490a81dce9cc~tplv-k3u1fbpfcp-watermark.image?)

```javascript
// tokens
[
	{ type: 'tag', name: 'div' },
	{ type: 'tag', name: 'p' },
	{ type: 'text', context: 'Vue' },
	{ type: 'tagEnd', name: 'p' },
	{ type: 'tag', name: 'p' },
	{ type: 'text', context: 'Template' },
	{ type: 'tagEnd', name: 'p' },
	{ type: 'tagEnd', name: 'div' }
]
```

```javascript
// 模版AST
{
  type: 'Root',
  childrent: [
    {
      type: 'Element',
      tag: 'div',
      children: [
        {
          type: 'Element',
          tag: 'p'
          children: [{ type: 'Text', content: 'Vue' }]
        },
    		{
          type: 'Element',
          tag: 'p'
          children: [{ type: 'Text', content: 'Template' }]
        },
      ]
    }
  ]
}
```



**第二步 transform：** 这里为第一步生成的**模板AST**中树的每一个节点添加一个 **jsNode**，也就是 **JavaScriptAST**

这里我们为什么不直接将模板AST转换成目标代码呢？

因为我们需要将模板AST编译成渲染函数，而渲染函数是由 JavaScript 代码来描述的，因此，我们需要将**模板AST**转换成用于**描述渲染函数的AST**，即 **JavaScriptAST**。下面举个例子更清楚的去了解这句话的意思：

`<div><p>Vue</p><p>Template</p></div>`模板最终返回的渲染函数如下：

```javascript
render() {
	return h('div', [
    h('p', 'Vue'),
    h('p', 'Template')
  ])
}
```

而 transform 要做的工作就是将第一步中的模板AST转换成如下用于描述渲染函数的数据结构

```js
const FunctionDeclNode = {
    type: 'FunctionDecl', // 节点类型
    // 函数名称
    id: { type: 'Identifier', name: 'render'},
    // 函数参数
    params: [],
    // 函数体
    body: [
        {
            type: 'ReturnStatement',
            return: {
                type: 'CallExpression',
                callee: { type: 'Indentifier', name: 'h' },
                arguments: [
                    { type: 'StringLiteral', value: 'div' },
                    {
                        type: 'ArrayExpression',
                        elements: [
                            {
                                type: 'CallExpression',
                                callee: { type: 'Indentifier', name: 'h' },
                                arguments: [
                                    { type: 'StringLiteral', value: 'p' },
                                    { type: 'StringLiteral', value: 'Vue'}
                                ]
                            },
                            {
                                type: 'CallExpression',
                                callee: { type: 'Indentifier', name: 'h' },
                                arguments: [
                                    { type: 'StringLiteral', value: 'p' },
                                    { type: 'StringLiteral', value: 'Template' }
                                ]
                            }
                        ]
                    }
                ]
            }
        }
    ]
}
```



**第三步 generate：** 在第二步中我们获取了描述渲染函数的 ast，这一步中我们根据该 ast 进行字符串的拼接得倒渲染函数据即可。

```javascript
render() {
	return h('div', [
    h('p', 'Vue'),
    h('p', 'Template')
  ])
}
```



## 5 parse详解















